# C++设计模式

**注：**

> 本文档为学习设计模式时整理收集的博客、文档、笔记。 版权为[原作者](https://blog.csdn.net/liang19890820/article/details/66974516)所有，如有侵权立即删除



# 设计模式概述

设计模式（Design Pattern）代表了最佳的实践，在面向对象的编程中被很多老鸟们反复使用。使用设计模式有很多好处：

- 可重用代码
- 保证代码可靠性
- 使代码更易被他人理解
- ……

毫无疑问，设计模式于己、于人、于系统都是多赢的。《设计模式》之于程序员，就好比《圣经》之于耶稣信徒一样，意义可想而知！



## 什么是 GoF

谈及设计模式，必然离不开 GoF：

> GoF：Gang of Four，也称为“四人组”，即：EErich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人。

1994 年，这几位大牛合著出版了一本名为《Design Patterns: Elements of Reusable Object-Oriented Software》（即：《设计模式》）的书。该书首次提到了软件开发中设计模式的概念，将设计模式提升到理论高度，并将之规范化。书中提及了 23 种基本设计模式，时至今日，在可复用面向对象软件的发展过程中，新的设计模式仍然不断出现。

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603135749.png" width="500px" /> </div>

这就是传说中的“风尘四侠”，比起国外的其他技术大咖（不修边幅），看起来要好很多~~O(∩_∩)O~~。

## 设计模式的类型★

根据《设计模式》参考书，共有 23 种设计模式，这些模式可以分为三类：

| 类型                              | 描述                                             |
| --------------------------------- | ------------------------------------------------ |
| 创建型模式（Creational Patterns） | 用于构建对象，以便它们可以从实现系统中分离出来。 |
| 结构型模式（Structural Patterns） | 用于在许多不同的对象之间形成大型对象结构。       |
| 行为型模式（Behavioral Patterns） | 用于管理对象之间的算法、关系和职责。             |

## 创建型模式

- [单例模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/单例模式.md)（Singleton Pattern） 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

- [简单工厂模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/简单工厂模式.md)（Simple Factory Pattern）由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类的实例。

- [抽象工厂模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/抽象工厂.md) （Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

- [建造者模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/建造者模式.md)（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- [工厂方法模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/工厂方法.md) （Factory Method Pattern） 定义一个用于创建对象的接口，让子类决定将哪一个类实例化，使一个类的实例化延迟到其子类。

- [原型模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/原型模式.md)（Prototype Pattern） 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

## 结构型模式

- [适配器模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/适配器模式.md)（Adapter Pattern） 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- [桥接模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/桥接模式.md)（Bridge Pattern） 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- [装饰者模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/装饰者模式.md)（Decorator Pattern） 动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。
- [组合模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/组合模式.md)（Composite Pattern） 将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。
- [外观模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/外观模式.md)（Facade Pattern） 为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- [享元模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/享元模式.md)（Flyweight Pattern） 运用共享技术有效地支持大量细粒度的对象。
- [代理模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/代理模式.md)（Proxy Pattern） 为其他对象提供一个代理以控制对这个对象的访问。

## 行为型模式

- [模版方法模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/模板方法.md) （Template Method Pattern） 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
- [命令模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/命令模式.md)（Command Pattern） 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
- 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。
- [观察者模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/观察者模式.md)（Observer Pattern） 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
- [中介者模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/中介者模式.md)（Mediator Pattern） 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
- [备忘录模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/备忘录模式.md) （Memento Pattern） 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
- 解释器模式（Interpreter Pattern） 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
- [状态模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/状态模式.md)（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
- [策略模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/策略模式.md)（Strategy Pattern） 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。
- [职责链模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/职责链模式.md) （Chain of Responsibility Pattern） 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
- [访问者模式](https://github.com/zejiedu/Design-Pattern/blob/master/设计模式/访问者模式.md) （Visitor Pattern） 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## N 问设计模式

- GoF 中提出的设计模式，至今仍被人津津乐道，你了解多少呢？

  - 没听过
  - 听说过，不知道具体能干嘛
  - 了解，会用其中的两三种
  - 熟悉，能根据实际情况快速设计
  - 精通，游刃有余

  第一种：“虽然不懂你们在说什么，貌似很厉害的样子”。大牛才会用到的东西，高端而又神秘！ 最后一种：“已上天，正和太阳肩并肩”。心中未曾想用设计模式，写出的代码却处处都是。 倘若你和我一样，属于其他情况。。。那么，就认真学习吧！

- 设计模式能带给你什么？

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603135821.png" width="600px" /> </div>

  从“猿猴 -> 程序猿 ”的巨变，怎么样，是不是很炫酷？

- 有些人说设计模式没用，真是这样吗？

  引用一句哲学名言：存在即合理。当然，若要扯非 OO 语言，也许真没什么用！但可以肯定的是，非 OO 语言完全可以借鉴 OO 的思想，设计模式也不例外！

- 设计模式有多重要？

  要做一位大神或所谓的高手，基本之一就是要懂得若干设计模式。设计模式是软件工程的基石脉络，如同大厦的结构一样，你说有多重要？

- 怎么学习设计模式？

  设计模式不是基于理论发明的，而是先有问题场景，再基于需求和情景不断演化设计方案，最后把一些方案标准化成“模式”。

  所以，通过实际案例学习是最好的！在讨论每一个设计模式时，要尽量用生活中的真实问题来理解和分析。然后尝试一步步地阐述设计，并以一个能匹配某些模式的设计收尾。

  通过先分析问题，然后阐述解决方案，最后得到一个设计模式，这样就不用死记那些图形和定义了！

- 如何选择设计模式？

  设计模式是针对某种情景下某种问题的某种解决方案，也就是说，每个模式都有自己的使用场景、使用方法和使用后果。正所谓物有两极，各模式也存在相应的优缺点，得其优，而避其劣，终得之！

- 为什么要写设计模式？

  虽然设计模式被很多人念叨并不断书写，但笔者还是决定追随前人的脚步。我很喜欢一句话：“你会了不代表你真的会，要是你能让别人也会，你才是正的会了”！

## 源码地址

要真正领悟设计模式的精髓，需要有大量实践经验的积累，这往往是一个漫长的过程。

博客中涉及的所有设计模式都基于实际案例，经过反复打磨。。。为了使其更加生动、形象，每个模式都有相应的故事化讲解。

相关源码均在code文件夹 中可以找到，全部经过验证。

- 参考code文件夹

  ```
  code
  ├─AbstractFactory
  ├─Adapter
  ├─Bridge
  ├─Builder
  ├─ChainOfResponsibility
  ├─Composite
  ├─Decorator
  ├─Facade
  ├─FactoryMethod
  ├─Flyweight
  ├─Mediator
  ├─Memento
  ├─Observer
  ├─Prototype
  ├─Proxy
  ├─SimpleFactory
  ├─Singleton
  ├─Strategy
  ├─TemplateMethod
  └─Visitor
  ```

- 注，代码来自GitHub 地址：[C++ Design Patterns](https://github.com/Waleon/DesignPatterns)



# 常用模式1：单例模式

## 简述

单例模式（Singleton Pattern）是设计模式中最简单的形式之一，其目的是**使得类的一个对象成为系统中的唯一实例**。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时**确保只有单个对象被创建**。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。

## UML 结构图

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603141342.png" width="400px" /> </div>

## 要点

单例模式的要点有三个：

- 单例类有且仅有一个实例
- 单例类必须自行创建自己的唯一实例
- 单例类必须给所有其他对象提供这一实例

从具体实现角度来说，可分为以下三点：

- 提供一个 private 构造函数（防止外部调用而构造类的实例）
- 提供一个该类的 static private 对象
- 提供一个 static public 函数，用于创建或获取其本身的静态私有对象（例如：GetInstance()）

除此之外，还有一些关键点（需要多加注意，很容易忽视）：

- 线程安全（双检锁 - DCL，即：double-checked locking）
- 资源释放



## 单例写法速览★

```cpp
// 单例 - 懒汉式/饿汉式公用
class Singleton
{
public:
    static Singleton* GetInstance();

private:
    Singleton() {}  // 构造函数（被保护）
    static Singleton *p;  // 指向单例对象的指针
    // static std::mutex m_mutex; // 用于线程安全的懒汉式单例
};

// 单例 - 懒汉式（非线程安全）
Singleton *Singleton::p = NULL; // 在第一次用到类实例的时候才会去实例化
Singleton *Singleton::GetInstance()
{
    if (p == NULL)
        p = new Singleton();
    return p;
}

// 单例 - 饿汉式（线程安全）
Singleton *Singleton::p = new Singleton(); // 在单例类定义的时候就进行实例化
Singleton *Singleton::GetInstance()
{
    return p;
}

// 单例 - 懒汉式（双检锁 DCL 机制，线程安全）
Singleton *Singleton::p = NULL;
std::mutex Singleton::m_mutex;
Singleton *Singleton::GetInstance()
{
    if (p == NULL) { // 第一次检查，判断是否要创建对象
        std::lock_guard<std::mutex> lock(m_mutex);  // 自解锁
        if (p == NULL) { // 第二次检查，避免多线程重复创建对象
            p = new Singleton();
        }
    }
    return p;
}
```



## 局部静态变量

这种方式很常见，实现非常简单，而且无需担心单例的销毁问题。

```cpp
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H

// 非真正意义上的单例
class Singleton
{
public:
    static Singleton& GetInstance()
    {
        static Singleton instance;
        return instance;
    }

private:
    Singleton() {}
};
```



但是，这并非真正意义上的单例。当使用如下方式访问单例时：

```cpp
Singleton single = Singleton::GetInstance();
```



这会出现了一个类拷贝问题，从而违背了单例的特性。产生这个问题原因在于：编译器会生成一个默认的拷贝构造函数，来支持类的拷贝。

为了避免这个问题，有两种解决方式：

1. 将 GetInstance() 函数的返回类型修改为指针，而非引用。
2. 显式地声明类的拷贝构造函数，并重载赋值运算符。

对于第一种方式，只需要修改 GetInstance() 的返回类型即可：

```cpp
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H

// 单例
class Singleton
{
public:
    // 修改返回类型为指针类型
    static Singleton* GetInstance()
    {
        static Singleton instance;
        return &instance;
    }

private:
    Singleton() {}
};

#endif // SINGLETON_H
```

既然编译器会生成一个默认的拷贝构造函数，那么，为什么不让编译器不这么干呢？这就产生了第二种方式：

```cpp
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H

#include <iostream>

using namespace std;

// 单例
class Singleton
{
public:
    static Singleton& GetInstance()
    {
        static Singleton instance;
        return instance;
    }

    void doSomething() {
        cout << "Do something" << endl;
    }

private:
    Singleton() {}  // 构造函数（被保护）
    Singleton(Singleton const &);  // 无需实现
    Singleton& operator = (const Singleton &);  // 无需实现
};

#endif // SINGLETON_H
```



这样一来，既可以保证只存在一个实例，又不用考虑内存回收的问题。

```cpp
Singleton::GetInstance().doSomething();  // OK
Singleton single = Singleton::GetInstance();  // Error 不能编译通过
```



## 懒汉式/饿汉式

在讲解之前，先看看 Singleton 的头文件（懒汉式/饿汉式公用）：

```cpp
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H

// 单例 - 懒汉式/饿汉式公用
class Singleton
{
public:
    static Singleton* GetInstance();

private:
    Singleton() {}  // 构造函数（被保护）

private:
    static Singleton *m_pSingleton;  // 指向单例对象的指针
};

#endif // SINGLETON_H
```

懒汉式的特点：

- Lazy 初始化
- 非多线程安全

优点：第一次调用才初始化，避免内存浪费。

缺点：必须加锁（在“线程安全”部分分享如何加锁）才能保证单例，但加锁会影响效率。

```cpp
// singleton.cpp
#include "singleton.h"

// 单例 - 懒汉式
Singleton *Singleton::m_pSingleton = NULL;

Singleton *Singleton::GetInstance()
{
    if (m_pSingleton == NULL)
        m_pSingleton = new Singleton();

    return m_pSingleton;
}
```



饿汉式的特点：

- 非 Lazy 初始化
- 多线程安全

优点：没有加锁，执行效率会提高。

缺点：类加载时就初始化，浪费内存。

```cpp
// singleton.cpp
#include "singleton.h"

// 单例 - 饿汉式
Singleton *Singleton::m_pSingleton = new Singleton();

Singleton *Singleton::GetInstance()
{
    return m_pSingleton;
}
```



## 线程安全

在懒汉式下，如果使用多线程，会出现线程安全隐患。为了解决这个问题，我们引入了双检锁 - DCL 机制。

```cpp
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H

#include <iostream>
#include <mutex>
using namespace std;

// 单例 - 懒汉式/饿汉式公用
class Singleton
{
public:
    static Singleton* GetInstance();

private:
    Singleton() {}  // 构造函数（被保护）

private:
    static Singleton *m_pSingleton;  // 指向单例对象的指针
    static mutex m_mutex;  // 锁
};

#endif // SINGLETON_H


// singleton.cpp
#include "singleton.h"

// 单例 - 懒汉式（双检锁 DCL 机制）
Singleton *Singleton::m_pSingleton = NULL;
mutex Singleton::m_mutex;

Singleton *Singleton::GetInstance()
{
    if (m_pSingleton == NULL) {
        std::lock_guard<std::mutex> lock(m_mutex);  // 自解锁
        if (m_pSingleton == NULL) {
            m_pSingleton = new Singleton();
        }
    }
    return m_pSingleton;
}
```

这样，就可以保证线程安全了，但是，会带来较小的性能影响。

**需要进行两次检验的原因**：

​	第一次判断是为了验证是否创建对象，第二次判断是为了避免重复创建单例，因为可能会存在多个线程通过了第一次判断在等待锁，进	而创建新的实例对象。

- 当A与B同时调用GetInstance时，判断第一个if都为空，这时A拿到锁，进行第二层if判断，条件成立new了一个对象；
- B在外层等待，A创建完成，释放锁，B拿到锁，进行第二层if判断，条件不成立，结束释放锁；
- C调用GetInstance时第一层判断不成立，直接拿到singleton对象返回，避免进入锁，减少性能开销。



## 资源释放

有内存申请，就要有对应的释放，可以采用下述两种方式：

- 主动释放（手动调用接口来释放资源）
- 自动释放（由程序自己释放）

要手动释放资源，添加一个 static 接口，编写需要释放资源的代码：

```cpp
// 单例 - 主动释放
static void DestoryInstance()
{
    if (m_pSingleton != NULL) {
        delete m_pSingleton;
        m_pSingleton = NULL;
    }
}
```



然后在需要释放的时候，手动调用该接口：

```cpp
Singleton::GetInstance()->DestoryInstance();
```



方式虽然简单，但很多时候，容易忘记调用 destoryInstance()。这时，可以采用更方便的方式：

```cpp
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H

#include <iostream>

using namespace std;

// 单例 - 自动释放
class Singleton
{
public:
    static Singleton* GetInstance();

private:
    Singleton() {}  // 构造函数（被保护）

private:
    static Singleton *m_pSingleton;  // 指向单例对象的指针

    // GC 机制
    class GC
    {
    public:
        ~GC()
        {
            // 可以在这里销毁所有的资源，例如：db 连接、文件句柄等
            if (m_pSingleton != NULL) {
                cout << "Here destroy the m_pSingleton..." << endl;
                delete m_pSingleton;
                m_pSingleton = NULL;
            }
        }
        static GC gc;  // 用于释放单例
    };
};

#endif // SINGLETON_H
```



只需要声明 Singleton::GC 即可：

```cpp
// main.cpp
#include "singleton.h"

Singleton::GC Singleton::GC::gc; // 重要

int main()
{
    Singleton *pSingleton1 = Singleton::GetInstance();
    Singleton *pSingleton2 = Singleton::GetInstance();

    cout << (pSingleton1 == pSingleton2) << endl;

    return 0;
}
```

在程序运行结束时，系统会调用 Singleton 的静态成员 GC 的析构函数，该析构函数会进行资源的释放。这种方式的最大优点就是在“不知不觉”中进行，所以，对我们来说，尤为省心。



# 常用模式2：简单工厂模式

## 简述

> 简单工厂模式（Simple Factory Pattern）又叫做静态工厂方法模式（Static Factory Method Pattern），属于创建型模式。简单工厂模式的实质是**由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类的实例**。

值得注意的是，简单工厂模式并不属于 23 种 GoF 设计模式之一。它是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200606153725.png" width="550px" /> </div>

- 工厂（Factory）：整个模式的核心，负责实现创建所有实例的内部逻辑。
- 抽象产品（Product）：所有具体产品的父类，负责描述所有实例所共有的公共接口。
- 具体产品（ConcreteProduct）：最终创建的具体产品



## 优缺点

优点：

- 工厂类包含了必要的逻辑判断，根据指定的信息来创建对应的产品。客户端仅负责“消费”产品即可，**实现了对象创建和使用的分离**。
- 客户端无需关心具体产品如何创建与组织，仅需知道具体产品所对应的参数即可，可以在一定程度减少使用者的记忆量。

缺点：

- 由于工厂类集中了所有产品的创建逻辑（违反了高内聚责任分配原则），职责过重，一旦无法正常工作，整个系统都将受到影响。
- 一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 这些缺点在 **C++工厂方法模式** 中得到了一定的克服。



## 适用场景

- 工厂类负责创建的对象比较少（不会造成工厂方法中的业务逻辑太过复杂）。
- 客户端仅需知道传入工厂类的参数，对于如何创建对象（逻辑）不关心。 PS： 由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。



## 案例分析

BBA - 奔驰、宝马、奥迪

互联网行业有三巨头 BAT，汽车界也有三大豪门 BBA - 奔驰、宝马、奥迪。他们是驰名世界的汽车企业，也被认为是高档汽车生产的先导，最可怕的是均属于德国制造。奔驰优雅稳重、宝马操控感强、奥迪大气，更是官车的代表。。。“坐奔驰，开宝马”，足以说明一切。在国内，BBA 大受欢迎，对很多人来说，不仅是代步工具，更是身份的象征。

车再好，也需要在工厂中加工生产，来一起看看简单工厂模式吧！



## 代码实现

### 创建抽象产品

示例中，需要有一个汽车产品 - ICar：

```cpp
// product.h
#ifndef PRODUCT_H
#define PRODUCT_H

#include <string>

using namespace std;

// 汽车接口
class ICar
{
public:
    virtual string Name() = 0;  // 汽车名称
};

#endif // PRODUCT_H
```



### 创建具体产品

模型有了，来创建一些具体的汽车：

```cpp
// concrete_product.h
#ifndef CONCRETE_PRODUCT_H
#define CONCRETE_PRODUCT_H

#include "product.h"

// 奔驰汽车
class BenzCar : public ICar
{
public:
    string Name() {
        return "Benz Car";
    }
};

// 宝马汽车
class BmwCar : public ICar
{
public:
    string Name() {
        return "Bmw Car";
    }
};

// 奥迪汽车
class AudiCar : public ICar
{
public:
    string Name() {
        return "Audi Car";
    }
};

#endif // CONCRETE_PRODUCT_H
```



### 创建工厂

要生产汽车，需要有相应的工厂：

```cpp
// factory.h
#ifndef FACTORY_H
#define FACTORY_H

#include "concrete_product.h"

// 工厂
class Factory
{
public:
    enum CAR_TYPE {
       BENZ_CAR,  // 奔驰汽车
       BMW_CAR,  // 宝马汽车
       AUDI_CAR  // 奥迪汽车
    };

    // 生产汽车
    ICar* CreateCar(CAR_TYPE type) {
        ICar *pCar = NULL;
        switch(type) {
        case CAR_TYPE::BENZ_CAR:
            pCar = new BenzCar();  // 奔驰汽车
            break;
        case CAR_TYPE::BMW_CAR:
            pCar = new BmwCar();  // 宝马汽车
            break;
        case CAR_TYPE::AUDI_CAR:
            pCar = new AudiCar();  // 奥迪汽车
            break;
        default:
            break;
        }
        return pCar;
    }
};

#endif // FACTORY_H
```

这样一来，工厂就可以根据汽车类型来生产对应的汽车了。



### 创建客户端

当一切准备就绪，就可以实现客户端了：

```cpp
// main.cpp
#include "factory.h"
#include "product.h"
#include <iostream>

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    // 工厂
    Factory *pFactory = new Factory();

    // 奔驰汽车
    ICar *pCar = pFactory->CreateCar(Factory::BENZ_CAR);
    cout << pCar->Name() << endl;
    
    SAFE_DELETE(pCar);
    
    // 宝马汽车
    pCar = pFactory->CreateCar(Factory::BMW_CAR);
    cout << pCar->Name() << endl;
    
    SAFE_DELETE(pCar);
    
    // 奥迪汽车
    pCar = pFactory->CreateCar(Factory::AUDI_CAR);
    cout << pCar->Name() << endl;
    
    SAFE_DELETE(pCar);
    
    getchar();
    
    return 0;
}
```

输出如下：

```
Benz Car 
Bmw Car 
Audi Car
```



# 常用模式3：工厂方法模式

## 简述

> 工厂方法模式（Factory Method Pattern）是一种常用的对象创建型设计模式，此模式的核心思想是**封装类中不变的部分，提取其中个性化善变的部分为独立类**，通过依赖注入以达到解耦、复用以及方便后期维护拓展的目的。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com/MrRen-sdhm/Images/raw/master/img/20200823110349.png" width="700px" /> </div>

- Factory（抽象工厂）：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
- ConcreteFactory（具体工厂）：实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且被应用程序调用以创建产品对象。
- Product（抽象产品）：所创建对象的基类，也就是具体产品的共同父类或共同拥有的接口。
- ConcreteProduct（具体产品）：实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。



## 优缺点

优点:

- 克服了简单工厂模式违背开放-封闭原则的缺点，又保留了封装对象创建过程的优点，**降低客户端和工厂的耦合性**。所以说，“工厂方法模式” 是 “简单工厂模式” 的进一步抽象和推广。

缺点:

- 每增加一个产品，相应的也要增加一个子工厂，加大了额外的开发量。



## 适用场景

- 对于某个产品，调用者清楚地知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品来。
- 只是需要一种产品，而不想知道也不需要知道究竟是哪个工厂生产的，即最终选用哪个具体工厂的决定权在生产者一方，它们根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程对于使用者来说是透明的。



## 案例分析

工厂模式基本和简单工厂模式差不多，简单工厂模式 - 在产品子类添加时，需要添加一个判断分支，这违背了开放-封闭原则。因此，工厂模式就是为了解决这个问题而产生的。

所以，对于 简单工厂模式 一节中的 BBA 来说，要分别由对应的工厂来生产。



## 代码实现

### 创建抽象产品

在我们的示例中，需要有一个汽车产品 - ICar：

```cpp
// product.h
#ifndef PRODUCT_H
#define PRODUCT_H

#include <string>

using namespace std;

// 汽车接口
class ICar
{
public:
    virtual string Name() = 0;  // 汽车名称
};

#endif // PRODUCT_H
```



### 创建具体产品

有了抽象产品，继续为其创建一些具体的产品：

```cpp
// concrete_product.h
#ifndef CONCRETE_PRODUCT_H
#define CONCRETE_PRODUCT_H

#include "product.h"

// 奔驰汽车
class BenzCar : public ICar
{
public:
    string Name() {
        return "Benz Car";
    }
};

// 宝马汽车
class BmwCar : public ICar
{
public:
    string Name() {
        return "Bmw Car";
    }
};

// 奥迪汽车
class AudiCar : public ICar
{
public:
    string Name() {
        return "Audi Car";
    }
};

#endif // CONCRETE_PRODUCT_H
```



### 创建工厂

产品有了，当然要有相应的工厂来生产，但在这之前，需要一个抽象工厂：

```cpp
// factory.h
#ifndef FACTORY_H
#define FACTORY_H

#include "product.h"

// 工厂接口
class AFactory
{
public:
    virtual ICar* CreateCar() = 0;  // 生产汽车
};

#endif // FACTORY_H
```



### 创建具体工厂

为每个制造商创建对应的的工厂：

```cpp
// concrete_factory.h
#ifndef CONCRETE_FACTORY_H
#define CONCRETE_FACTORY_H

#include "factory.h"
#include "concrete_product.h"

// 奔驰工厂
class BenzFactory : public AFactory
{
public:
    ICar* CreateCar() {
        return new BenzCar();
    }
};

// 宝马工厂
class BmwFactory : public AFactory
{
public:
    ICar* CreateCar() {
        return new BmwCar();
    }
};

// 奥迪工厂
class AudiFactory : public AFactory
{
public:
    ICar* CreateCar() {
        return new AudiCar();
    }
};

#endif // CONCRETE_FACTORY_H
```

这样一来，每个工厂只负责生产自己的产品。



### 创建客户端

当一切准备就绪，就可以实现客户端了：

```cpp
// main.cpp
#include "concrete_factory.h"
#include "product.h"
#include <iostream>

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    // 奔驰
    AFactory *pFactory = new BenzFactory();
    ICar *pCar = pFactory->CreateCar();
    cout << "Benz factory: " << pCar->Name() << endl;

    SAFE_DELETE(pCar);
    SAFE_DELETE(pFactory);
    
    // 宝马
    pFactory = new BmwFactory();
    pCar = pFactory->CreateCar();
    cout << "Bmw factory: " << pCar->Name() << endl;
    
    SAFE_DELETE(pCar);
    SAFE_DELETE(pFactory);
    
    // 奥迪
    pFactory = new AudiFactory();
    pCar = pFactory->CreateCar();
    cout << "Audi factory: " << pCar->Name() << endl;
    
    SAFE_DELETE(pCar);
    SAFE_DELETE(pFactory);
    
    getchar();
    
    return 0;
}
```

输出如下：

```
Benz factory: Benz Car Bmw factory: Bmw Car Audi factory: Audi Car
```



# 常用模式4：抽象工厂模式

## 简述

抽象工厂模式（Abstract Factory Pattern）是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指**当有多个抽象角色时，使用的一种工厂模式**。抽象工厂模式可以向客户端提供一个接口，**使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象**。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603141554.png" width="750px" /> </div>

- Factory（抽象工厂）：声明一个用于创建抽象产品的接口
- ConcreteFactory（具体工厂）：用于创建具体的产品
- Product（抽象产品）：声明一个产品对象类型的接口
- ConcreteProduct（具体产品）：由具体工厂创建的具体产品



## 优缺点

优点：

- **封装了产品的创建，使得不需要知道具体是哪种产品，只需要知道是哪个工厂即可**。
- **可以支持不同类型的产品，使得模式灵活性更强**。
- 可以非常方便的使用一族中的不同类型的产品。

缺点：

- 结构过于臃肿，如果产品类型较多或产品族较多，会非常难于管理。
- 每次如果添加一组产品，那么所有的工厂类都必须添加一个方法，这样违背了开放-封闭原则。所以一般适用于产品组合产品族变化不大的情况。



## 适用场景

- 在不必指定产品的具体的情况下，创建多个产品族中的产品对象。



## 案例分析

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603133128.png" width="400px" /> </div>

工厂方法模式要求产品必须为同一类型，也就是说，BBA 只能生产汽车，要生产其他产品（例如：自行车）是不行的，这显然限制了产品的扩展。为了解决这个问题，抽象工厂模式出现了 - **将产品归类分组，然后将好几组产品构成一族**。每个工厂负责生产一族产品，而工厂中的每个方法负责生产一种类型的产品。

这样，客户端只需要创建具体工厂的实例，然后调用工厂对象的工厂方法就可以得到所需要的产品对象。



## 代码实现

### 创建抽象产品

在我们的示例中，需要有两个产品 - 汽车和自行车：

```cpp
// product.h
#ifndef PRODUCT_H
#define PRODUCT_H

#include <string>

using namespace std;

// 汽车接口
class ICar
{
public:
    virtual string Name() = 0;  // 汽车名称
};

// 自行车接口
class IBike
{
public:
    virtual string Name() = 0;  // 自行车名称
};

#endif // PRODUCT_H
```



### 创建具体产品

有了抽象产品，继续创建一些具体的产品：

```cpp
// concrete_product.h
#ifndef CONCRETE_PRODUCT_H
#define CONCRETE_PRODUCT_H

#include "product.h"

/********** 汽车 **********/
// 奔驰
class BenzCar : public ICar
{
public:
    string Name() {
        return "Benz Car";
    }
};

// 宝马
class BmwCar : public ICar
{
public:
    string Name() {
        return "Bmw Car";
    }
};

// 奥迪
class AudiCar : public ICar
{
public:
    std::string Name() {
        return "Audi Car";
    }
};

/********** 自行车 **********/
// 奔驰
class BenzBike : public IBike
{
public:
    string Name() {
        return "Benz Bike";
    }
};

// 宝马
class BmwBike : public IBike
{
public:
    string Name() {
        return "Bmw Bike";
    }
};

// 奥迪
class AudiBike : public IBike
{
public:
    string Name() {
        return "Audi Bike";
    }
};

#endif // CONCRETE_PRODUCT_H
```

这样，为汽车和自行车都准备好了所有的具体类。



### 创建抽象工厂

产品有了，当然要有相应的制造商与其相关联，所以呢，要有具体的工厂。但在这之前，需要一个抽象工厂：

```cpp
// factory.h
#ifndef FACTORY_H
#define FACTORY_H

#include "product.h"

// 抽象工厂
class AFactory
{
public:
    enum FACTORY_TYPE {
        BENZ_FACTORY,  // 奔驰工厂
        BMW_FACTORY,  // 宝马工厂
        AUDI_FACTORY  // 奥迪工厂
    };

    virtual ICar* CreateCar() = 0;  // 生产汽车
    virtual IBike* CreateBike() = 0;    // 生产自行车
    static AFactory* CreateFactory(FACTORY_TYPE factory);  // 创建工厂
};

#endif // FACTORY_H
// factory.cpp
#include "factory.h"
#include "concrete_factory.h"

// 创建工厂
AFactory* AFactory::CreateFactory(FACTORY_TYPE factory)
{
    AFactory *pFactory = NULL;
    switch (factory) {
    case FACTORY_TYPE::BENZ_FACTORY:  // 奔驰工厂
        pFactory = new BenzFactory();
        break;
    case FACTORY_TYPE::BMW_FACTORY:  // 宝马工厂
        pFactory = new BmwFactory();
        break;
    case FACTORY_TYPE::AUDI_FACTORY:  // 奥迪工厂
        pFactory = new AudiFactory();
        break;
    default:
        break;
    }
    return pFactory;
}
```



### 创建具体工厂

为每个制造商创建具体的工厂：

```cpp
// concrete_factory.h
#ifndef CONCRETE_FACTORY_H
#define CONCRETE_FACTORY_H

#include "factory.h"
#include "concrete_product.h"

// 奔驰工厂
class BenzFactory : public AFactory
{
public:
    ICar* CreateCar() {
        return new BenzCar();
    }

    IBike* CreateBike() {
        return new BenzBike();
    }
};

// 宝马工厂
class BmwFactory : public AFactory
{
public:
    ICar* CreateCar() {
        return new BmwCar();
    }

    IBike* CreateBike() {
        return new BmwBike();
    }
};

// 奥迪工厂
class AudiFactory : public AFactory
{
public:
    ICar* CreateCar() {
        return new AudiCar();
    }

    IBike* CreateBike() {
        return new AudiBike();
    }
};

#endif // CONCRETE_FACTORY_H
```

这样一来，具体的产品就与其制造商关联起来了。



### 创建客户端

当一切准备就绪，就可以实现客户端了，利用相关产品的这种层次结构来创建产品。

```cpp
// main.cpp
#include "factory.h"
#include "product.h"
#include <iostream>

using namespace std;

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    // 奔驰
    AFactory *pFactory = AFactory::CreateFactory(AFactory::FACTORY_TYPE::BENZ_FACTORY);
    ICar *pCar = pFactory->CreateCar();
    IBike *pBike = pFactory->CreateBike();

    cout << "Benz factory - Car: " << pCar->Name() << endl;
    cout << "Benz factory - Bike: " << pBike->Name() << endl;

    SAFE_DELETE(pCar);
    SAFE_DELETE(pBike);
    SAFE_DELETE(pFactory);

    // 宝马
    pFactory = AFactory::CreateFactory(AFactory::FACTORY_TYPE::BMW_FACTORY);
    pCar = pFactory->CreateCar();
    pBike = pFactory->CreateBike();
    cout << "Bmw factory - Car: " << pCar->Name() << endl;
    cout << "Bmw factory - Bike: " << pBike->Name() << endl;

    SAFE_DELETE(pCar);
    SAFE_DELETE(pBike);
    SAFE_DELETE(pFactory);

    // 奥迪
    pFactory = AFactory::CreateFactory(AFactory::FACTORY_TYPE::AUDI_FACTORY);
    pCar = pFactory->CreateCar();
    pBike = pFactory->CreateBike();
    cout << "Audi factory - Car: " << pCar->Name() << endl;
    cout << "Audi factory - Bike: " << pBike->Name() << endl;

    SAFE_DELETE(pCar);
    SAFE_DELETE(pBike);
    SAFE_DELETE(pFactory);

    getchar();

    return 0;
}
```

输出如下：

```
Benz factory - Car: Benz Car
Benz factory - Bike: Benz Bike
Bmw factory - Car: Bmw Car
Bmw factory - Bike: Bmw Bike
Audi factory - Car: Audi Car
Audi factory - Bike: Audi Bike
```

到这里，抽象工厂模式的基本框架已经有了，我们仅输出了具体产品的名字，其实还可以包含更多的信息，请根据需要自行扩展。



# 常用模式5：原型模式

## 简述

> 原型模式（Prototype Pattern）是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，而无需知道任何创建的细节。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com/MrRen-sdhm/Images/raw/master/img/20200823163902.png" width="600px" /> </div>

- Prototype（抽象原型）：定义了克隆自身的接口。
- ConcretePrototype（具体原型）：被复制的对象，需要实现 Prototype 定义的接口。



## 优缺点

优点：

- 如果创建新的对象比较复杂，可以利用原型模式简化对象的创建过程，同时也能够提高效率。
- 简化对象的创建，无需理会创建过程。
- 可以在程序运行时（对象属性发生了变化）获得一份内容相同的实例，他们之间不会相互干扰。

缺点：

- 在实现深拷贝时可能需要比较复杂的代码
- 需要为每一个类配备一个克隆方法，而且该克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。



## 适用场景

- 如果创建新对象成本较大，可以利用已有的对象进行复制来获得。
- 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。
- 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。



## 案例分析

你挑着担 我牵着马 迎来日出 送走晚霞 …… 敢问路在何方 路在脚下 敢问路在何方 路在脚下

一首《敢问路在何方》，触动了无数人的心弦。当年只要前奏一响，小伙伴们就再也把持不住了。。。《西游记》作为四大名著之一，可谓是家喻户晓，神一样的存在。从小到大，更是百看不厌。

记得孙悟空在打黄风怪、收七狮的时候，会拔一根猴毛，幻化为成千上万个孙悟空（猴哥、猴哥，你真了不得）。。。原型模式亦是如此，同样提供了自我复制功能。

注： 《西游记》中记载：孙悟空本是花果山上一块仙石所生，天地生成，无父母，无名无姓，拜菩提祖师处，得名孙悟空。

PS： 示例中的抽象原型为猴子（Monkey）类，而非仙石类，千万不要一脸懵逼！



## 代码实现

### 创建抽象原型

定义一个猴子类 Monkey，并提供一个 Clone() 接口，用于自我复制。

```cpp
// prototype.h
#ifndef PROTOTYPE_H
#define PROTOTYPE_H

// 猴子
class Monkey
{
public:
    Monkey(){}
    virtual ~Monkey(){}
    virtual Monkey* Clone() = 0;  // 克隆
    virtual void Play() = 0;  // 玩耍
};

#endif // PROTOTYPE_H
```



### 创建具体原型

美猴王腾空出世：

```cpp
// concrete_prototype.h
#ifndef CONCRETE_PROTOTYPE_H
#define CONCRETE_PROTOTYPE_H

#include "prototype.h"
#include <iostream>
#include <string>

using namespace std;

// 孙悟空
class SunWuKong : public Monkey
{
public:
    SunWuKong(string name){ m_strName = name; }
    ~SunWuKong(){}

    // 拷贝构造函数
    SunWuKong(const SunWuKong &other) {
        m_strName = other.m_strName;
    }
    Monkey* Clone() {
        // 调用拷贝构造函数
        return new SunWuKong(*this);
    }
    void Play() {
        cout << m_strName << " play Golden-Hoop-Stick" << endl;
    }

private:
    string m_strName;
};

#endif // CONCRETE_PROTOTYPE_H
```

同样是猴子，别的猴子玩的是 LOL，而孙悟空玩的是金箍棒（Golden-Hoop-Stick），谁要他是齐天大圣呢！



### 创建客户端

拔一根猴毛，吹出猴万个：

```cpp
// main.cpp
#include "concrete_prototype.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    // 孙悟空
    Monkey *pSWK = new SunWuKong("Qi Tian Da Sheng");

    // 克隆猴子猴孙
    Monkey *pSWK1 = pSWK->Clone();
    Monkey *pSWK2 = pSWK1->Clone();
    
    pSWK1->Play();
    pSWK2->Play();
    
    SAFE_DELETE(pSWK1);
    SAFE_DELETE(pSWK2);
    SAFE_DELETE(pSWK);
    
    getchar();
    
    return 0;
}
```

输出如下：

```
Qi Tian Da Sheng play Golden-Hoop-Stick Qi Tian Da Sheng play Golden-Hoop-Stick
```

除了孙悟空以外，我们还可以创建六耳猕猴，其实力和孙悟空一般无二，两者大战，闹的天翻地覆。。。真是快哉！



# 常用模式6：适配器模式

## 简述

> 适配器模式（Adapter Pattern）是一种补救模式，**将一个类的接口转换成客户希望的另外一个接口**，从而使原本由于接口不兼容而不能一起工作的类可以一起工作。



## 模式结构

UML 结构图（类适配器）：

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603135929.png" width="600px" /> </div>

UML 结构图（对象适配器）：

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603135939.png" width="600px" /> </div>

- Target（目标接口）：所期望得到的接口
- Adaptee（适配者）：需要适配的类
- Adapter（适配器）：该模式的核心，具有将 Adaptee 包装为 Target 的职责



## 类适配器和对象适配器

从实现层面上划分，适配器模式分为两种：

- 类适配器（多继承方式）
- 对象适配器（对象组合方式） 



那么，实际应用中如何在二者之间进行选择？

类适配器包含以下特点：

由于 Adapter 直接继承自 Adaptee 类，所以，在 Adapter 类中可以对 Adaptee 类的方法进行重定义。**如果在 Adaptee 中添加了一个抽象方法，那么 Adapter 也要进行相应的改动，这样就带来高耦合**。如果 Adaptee 还有其它子类，而在 Adapter 中想调用 Adaptee 其它子类的方法时，使用类适配器是无法做到的。

对象适配器包含以下特点：

有的时候，你会发现，去构造一个 Adaptee 类型的对象不是很容易。 **当 Adaptee 中添加新的抽象方法时，Adapter 类不需要做任何调整，也能正确的进行动作**。可以使用多态的方式在 Adapter 类中调用 Adaptee 类子类的方法。 由于对象适配器的耦合度比较低，所以在很多的书中都**建议使用对象适配器**。在我们实际项目中，也是如此，能使用对象组合的方式，就不使用多继承的方式。



## 优缺点

优点：

- 可以让任何两个没有关联的类一起运行
- 提高了类的复用
- 增加了类的透明度
- 灵活性好

缺点：

- 过多地使用适配器，会让系统非常凌乱，不利于整体把控。 例如，看到调用的是 A 接口，内部却被适配成了 B 接口的实现，系统如果出现太多类似情况，无异于一场灾难。因此，如果不是很必要，可以不使用适配器，而是直接对系统进行重构。



## 适用场景

- 当想使用一个已存在的类，而它的接口不符合需求时。
- 你想创建一个可复用的类，该类可以与其他不相关的类或不可预见的类协同工作。
- 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父接口。



## 案例分析

莫斯科 - 森林中的首都

莫斯科、圣彼得堡。。。作为俄罗斯的热门旅游景点，每年都会迎来成百上千万的游客，而中国稳居其第一大客源国。

要去俄罗斯旅游，手机必不可少，然而，让人头疼的是如何给手机充电！

世界各国插座标准都不尽相同，甚至同一国家的不同地区也可能不一样。例如，中国一般使用两脚扁型，而俄罗斯使用的是双脚圆形。那么，如果去俄罗斯旅游，就会出现一个问题：我们带去的充电器为两脚扁型，而他们提供的插座为双脚圆形，如何给手机充电呢？总不能为了旅客而随意更改墙上的插座吧，而且俄罗斯人一直都这么使用，并且用的很好。俗话说入乡随俗，那么只能自己想办法解决了。

其实这个问题的解决方式很简单 - 适配器模式，只需要提供一个电源转化器即可。该转化器的一端符合俄罗斯标准，可以插到俄罗斯的插座上，另一端符合中国标准，可以供我们的手机充电器使用。



## 代码实现

### 对象适配器

#### 创建目标接口

俄罗斯提供的插座：

```cpp
// target.h
#ifndef TARGET_H
#define TARGET_H

#include <iostream>

// 俄罗斯提供的插座
class IRussiaSocket
{
public:
    // 使用双脚圆形充电（暂不实现）
    virtual void Charge() = 0;
};

#endif // TARGET_H
```



#### 创建适配者

再来看看我们自带的充电器：

```cpp
// adaptee.h
#ifndef ADAPTEE_H
#define ADAPTEE_H

#include <iostream>

using namespace std;

// 自带的充电器 - 两脚扁型
class OwnCharger
{
public:
    void ChargeWithFeetFlat() {
        cout << "OwnCharger::ChargeWithFeetFlat" << endl;
    }
};

#endif // ADAPTEE_H
```



#### 创建适配器

定义一个电源适配器，并使用我们自带的充电器充电：

```cpp
// adapter.h
#ifndef ADAPTER_H
#define ADAPTER_H

#include "target.h"
#include "adaptee.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

// 电源适配器
class PowerAdapter : public IRussiaSocket
{
public:
    PowerAdapter() : m_pCharger(new OwnCharger()){}
    ~PowerAdapter() {
        SAFE_DELETE(m_pCharger);
    }
    void Charge() {
        //  使用自带的充电器（两脚扁型）充电
        m_pCharger->ChargeWithFeetFlat();
    }

private:
    OwnCharger *m_pCharger;  // 持有需要被适配的接口对象 - 自带的充电器
};

#endif // ADAPTER_H
```



#### 创建客户端

最终，客户端实现如下：

```cpp
// main.cpp
#include "adapter.h"

int main()
{
    // 创建适配器
    IRussiaSocket *pAdapter = new PowerAdapter();

    // 充电
    pAdapter->Charge();
    
    SAFE_DELETE(pAdapter);
    
    getchar();
    
    return 0;
}
```

输出如下：

OwnCharger::ChargeWithFeetFlat

这说明适配器起作用了，现在可以使用两脚扁型插孔充电了。我们并没有改变俄罗斯提供的插座，只提供了一个适配器就能使用中国的标准插口充电。这就是适配器模式的魅力：不改变原有接口，却还能使用新接口的功能。



### 类适配器

Target 和 Adaptee 保持不变，只需要将 Adapter 变为多继承的方式即可：

```cpp
#ifndef ADAPTER_H
#define ADAPTER_H

#include "target.h"
#include "adaptee.h"

// 电源适配器
class PowerAdapter : public IRussiaSocket, OwnCharger
{
public:
    PowerAdapter() {}
    void Charge() {
        // 使用自带的充电器（两脚扁型）充电
        ChargeWithFeetFlat();
    }
};

#endif // ADAPTER_H
```

除此之外，其他用法和“对象适配器”一致。



# 常用模式7：桥接模式

> 桥接模式（Bridge Pattern）是**将抽象部分与它的实现部分分离**，使它们都可以独立地变化。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603140105.png" width="650px" /> </div>

- Abstraction（抽象类）：用于定义抽象类的接口，并且维护一个指向 Implementor 实现类的指针。它与 Implementor 之间具有关联关系。
- RefinedAbstraction（扩充抽象类）：扩充由 Abstraction 定义的接口，在 RefinedAbstraction 中可以调用在 Implementor 中定义的业务方法。
- Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同。
- ConcreteImplementor（具体实现类）：实现了 Implementor 定义的接口，在不同的 ConcreteImplementor 中提供基本操作的不同实现。在程序运行时，ConcreteImplementor 对象将替换其父类对象，提供给 Abstraction 具体的业务操作方法。



## 优缺点

优点：

- 分离抽象和实现部分。桥接模式使用 “对象间的关联关系” **解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化**。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是 “子类化” 它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。
- 在很多情况下，桥接模式可以取代多重继承方案，多重继承方案违背了 “单一职责原则”，复用性较差，且类的个数非常多，**桥接模式是比多重继承方案更好的解决方法，它极大减少了子类的个数**。
- 桥接模式**提高了系统的可扩展性**，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合 “开闭原则”。

缺点：

- 桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。
- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。



## 适用场景

- 如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。
- “抽象部分” 和 “实现部分” 可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
- 一个系统存在多个（≥ 2）独立变化的维度，且这多个维度都需要独立进行扩展。
- 对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。



## 案例分析

开关和电器

电器是现代生活必不可少的东西，几乎每家每户都有，电视、风扇、电灯。。。无论什么电器，都由开关控制。开关种类众多，有拉链式开关、两位开关、调光开关。。。

不管任何时候，都可以在不触及其它东西的情况下更换设备。例如，可以在不更换开关的情况下换掉灯泡，也可以在不接触灯泡或风扇的情况下更换开关，甚至可以在不接触开关的情况下将灯泡和风扇互换。

这看起来很自然，当然也应该这样！当不同的事物联系到一起时，它们应该在一个可以变更或者替换的系统中，以便不相互影响或者影响尽可能的小，这样才能更方便、更低成本地去管理系统。想象一下，如果要换房间里的一个灯泡，得要求把开关也换了，你会考虑使用这样的系统吗？



## 代码实现

### 创建实现类接口

所有电器都有一些共性，可以被打开和关闭：

```cpp
// implementor.h
#ifndef IMPLEMENTOR_H
#define IMPLEMENTOR_H

// 电器
class IElectricalEquipment
{
public:
    virtual ~IElectricalEquipment() {}

    // 打开
    virtual void PowerOn() = 0;
    
    // 关闭
    virtual void PowerOff() = 0;
};

#endif // IMPLEMENTOR_H
```



### 创建具体实现类

接下来，是真正的电器 - 电灯和风扇，它们实现了 IElectricalEquipment 接口：

```cpp
// concrete_implementor.h
#ifndef CONCRETE_IMPLEMENTOR_H
#define CONCRETE_IMPLEMENTOR_H

#include "implementor.h"
#include <iostream>

// 电灯
class Light : public IElectricalEquipment
{
public:
    // 开灯
    virtual void PowerOn() override {
        std::cout << "Light is on." << std::endl;
    }

    // 关灯
    virtual void PowerOff() override {
        std::cout << "Light is off." << std::endl;
    }
};

// 风扇
class Fan : public IElectricalEquipment
{
public:
    // 打开风扇
    virtual void PowerOn() override {
        std::cout << "Fan is on." << std::endl;
    }

    // 关闭风扇
    virtual void PowerOff() override {
        std::cout << "Fan is off." << std::endl;
    }
};

#endif // CONCRETE_IMPLEMENTOR_H
```



### 创建抽象类

对于开关来说，它并不知道电灯和风扇的存在，只知道自己可以控制（打开/关闭）某个电器。也就是说，每个 ISwitch 应该持有一个 IElectricalEquipment 对象：

```cpp
// abstraction.h
#ifndef ABSTRACTION_H
#define ABSTRACTION_H

#include "implementor.h"

// 开关
class ISwitch
{
public:
    ISwitch(IElectricalEquipment *ee) { m_pEe = ee;}
    virtual ~ISwitch() {}

    // 打开电器
    virtual void On() = 0;
    
    // 关闭电器
    virtual void Off() = 0;

protected:
    IElectricalEquipment *m_pEe;
};

#endif // ABSTRACTION_H
```



### 创建扩充抽象类

特定类型的开关很多，比如拉链式开关、两位开关：

```cpp
// refined_abstraction.h
#ifndef REFINED_ABSTRACTION_H
#define REFINED_ABSTRACTION_H

#include "abstraction.h"
#include <iostream>

// 拉链式开关
class PullChainSwitch : public ISwitch
{
public:
    PullChainSwitch(IElectricalEquipment *ee) : ISwitch(ee) {}

    // 用拉链式开关打开电器
    virtual void On() override {
        std::cout << "Switch on the equipment with a pull chain switch." << std::endl;
        m_pEe->PowerOn();
    }
    
    // 用拉链式开关关闭电器
    virtual void Off() override {
        std::cout << "Switch off the equipment with a pull chain switch." << std::endl;
        m_pEe->PowerOff();
    }
};

// 两位开关
class TwoPositionSwitch : public ISwitch
{
public:
    TwoPositionSwitch(IElectricalEquipment *ee) : ISwitch(ee) {}

    // 用两位开关打开电器
    virtual void On() override {
        std::cout << "Switch on the equipment with a two-position switch." << std::endl;
        m_pEe->PowerOn();
    }
    
    // 用两位开关关闭电器
    virtual void Off() override {
        std::cout << "Switch off the equipment with a two-position switch." << std::endl;
        m_pEe->PowerOff();
    }
};

#endif // REFINED_ABSTRACTION_H
```



### 创建客户端

很好，是时候将开关和电器关联起来了：

```cpp
// main.cpp
#include "refined_abstraction.h"
#include "concrete_implementor.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    // 创建电器 - 电灯、风扇
    IElectricalEquipment *light = new Light();
    IElectricalEquipment *fan = new Fan();

    /**
     * 创建开关 - 拉链式开关、两位开关
     * 将拉链式开关和电灯关联起来，将两位开关和风扇关联起来
    **/
    ISwitch *pullChain = new PullChainSwitch(light);
    ISwitch *twoPosition= new TwoPositionSwitch(fan);
    
    // 开灯、关灯
    pullChain->On();
    pullChain->Off();
    
    // 打开风扇、关闭风扇
    twoPosition->On();
    twoPosition->Off();
    
    SAFE_DELETE(twoPosition);
    SAFE_DELETE(pullChain);
    SAFE_DELETE(fan);
    SAFE_DELETE(light);
    
    getchar();
    
    return 0;
}
```

输出如下：

```
Switch on the equipment with a pull chain switch. 
Light is on. 
Switch off the equipment with a pull chain switch. 
Light is off. 
Switch on the equipment with a two-position switch. 
Fan is on. 
Switch off the equipment with a two-position switch. 
Fan is off.
```



# 常用模式8：装饰者模式

## 简述

> 装饰者模式（Decorator Pattern）是在不必改变原类文件和使用继承的情况下，**动态地扩展一个对象的功能**。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com/MrRen-sdhm/Images/raw/master/img/20200823111804.png" width="600px" /> </div>

- Component（抽象构件）：给出一个抽象接口，以规范准备接收附加责任的对象。
- ConcreteComponent（具体构件）：定义一个将要接收附加责任的类。
- Decorator（抽象装饰类）：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。
- ConcreteDecorator（具体装饰类）：负责给构件对象添加上附加的责任。



## 优缺点

优点：

- Decorator 模式与继承关系的目的都是要**扩展对象的功能**，但是 Decorator 可以提供比继承更多的灵活性。
- 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。

缺点：

- 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。
- 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。
- 装饰模式是针对抽象构建（Component）类型编程。但是，如果要针对具体构件（ConcreteComponent）编程，应该重新思考应用架构，以及装饰者是否合适。当然也可改变 Component 接口，增加新的公开的行为，实现 “半透明” 的装饰者模式。在实际项目中要做出最佳选择。



## 适用场景

- 需要扩展一个类的功能，或给一个类添加附加职责。
- 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。
- 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。
- 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。



## 案例分析

星巴克（Starbucks）

在星巴克购买咖啡时，可以要求在其中加入各种调味品（辅料）。调味品很多，有些不收费（例如：白砂糖、香草粉等），有些则需要额外收费（例如：奶油、摩卡、糖浆等），所以充分利用起来吧！倘若咖啡不带劲，我们想要添加奶油、摩卡和糖浆，这时，就可以利用装饰者模式思想来实现。

关于星巴克，推荐两个比较火的事件：

老罗星巴克奇遇记（看一次笑十次 ~~O(∩_∩)O~~） 《致星巴克中国CEO王静瑛公开信：什么时候才不觉得中杯顾客无知或愚蠢?》



## 代码实现

### 创建构建

首先，定义所有饮料的基类，并提供名称和价钱：

```cpp
// component.h
#ifndef COMPONENT_H
#define COMPONENT_H

#include <string>

using namespace std;

// 所有饮料的基类
class IBeverage
{
public:
    virtual string Name() = 0;  // 名称
    virtual double Cost() = 0;  // 价钱
};

#endif // COMPONENT_H
```



### 创建具体构建

假设，有两款具体的咖啡 - 黑咖啡（属于混合咖啡）和深度烘培咖啡豆：

```cpp
// concrete_component.h
#ifndef CONCRETE_COMPONENT_H
#define CONCRETE_COMPONENT_H

#include "component.h"

/********** 具体的饮料（咖啡）**********/

// 黑咖啡，属于混合咖啡
class HouseBlend : public IBeverage
{
public:
    string Name() {
        return "HouseBlend";
    }

    double Cost() {
        return 30.0;
    }
};

// 深度烘培咖啡豆
class DarkRoast : public IBeverage
{
public:
    string Name() {
        return "DarkRoast";
    }

    double Cost() {
        return 28.5;
    }
};

#endif // CONCRETE_COMPONENT_H
```



### 创建装饰

咖啡有了，剩下的就是添加调味品，其同样继承 IBeverage，并持有咖啡的实例：

```cpp
// decorator.h
#ifndef DECORATOR_H
#define DECORATOR_H

#include "component.h"

// 调味品
class CondimentDecorator : public IBeverage
{
public :
    CondimentDecorator(IBeverage *beverage) : m_pBeverage(beverage) {}

    string Name() {
        return m_pBeverage->Name();
    }
    
    double Cost() {
        return m_pBeverage->Cost();
    }

protected :
    IBeverage *m_pBeverage;
} ;

#endif // DECORATOR_H
```



### 创建具体装饰

添加三种收费的调味品：

```cpp
// concrete_decorator.h
#ifndef CONCRETE_DECORATOR_H
#define CONCRETE_DECORATOR_H

#include "decorator.h"

/********** 具体的饮料（调味品）**********/

// 奶油
class Cream : public CondimentDecorator
{
public:
    Cream(IBeverage *beverage) : CondimentDecorator(beverage) {}

    string Name() {
        return m_pBeverage->Name() + " Cream";
    }
    
    double Cost() {
        return m_pBeverage->Cost() + 3.5;
    }
};

// 摩卡
class Mocha : public CondimentDecorator
{
public:
    Mocha(IBeverage *beverage) : CondimentDecorator(beverage) {}

    string Name() {
        return m_pBeverage->Name() + " Mocha";
    }
    
    double Cost() {
        return m_pBeverage->Cost() + 2.0;
    }
};

// 糖浆
class Syrup : public CondimentDecorator
{
public:
    Syrup(IBeverage *beverage) : CondimentDecorator(beverage) {}

    string Name() {
        return m_pBeverage->Name() + " Syrup";
    }
    
    double Cost() {
        return m_pBeverage->Cost() + 3.0;
    }
};

#endif // CONCRETE_DECORATOR_H
```



### 创建客户端

最终，我们可以为咖啡添加相应的调味品：

```cpp
// main.cpp
#include "concrete_component.h"
#include "concrete_decorator.h"
#include <iostream>

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    /********** 黑咖啡 **********/
    IBeverage *pHouseBlend = new HouseBlend();
    cout << pHouseBlend->Name() << " : " << pHouseBlend->Cost() << endl;

    // 黑咖啡 + 奶油
    CondimentDecorator *pCream = new Cream(pHouseBlend);
    cout << pCream->Name() << " : " << pCream->Cost() << endl;
    
    // 黑咖啡 + 摩卡
    CondimentDecorator *pMocha = new Mocha(pHouseBlend);
    cout << pMocha->Name() << " : " << pMocha->Cost() << endl;
    
    // 黑咖啡 + 糖浆
    CondimentDecorator *pSyrup = new Syrup(pHouseBlend);
    cout << pSyrup->Name() << " : " << pSyrup->Cost() << endl;
    
    /********** 深度烘培咖啡豆 **********/
    IBeverage *pDarkRoast = new DarkRoast();
    cout << pDarkRoast->Name() << " : " << pDarkRoast->Cost() << endl;
    
    // 深度烘培咖啡豆 + 奶油
    CondimentDecorator *pCreamDR = new Cream(pDarkRoast);
    cout << pCreamDR->Name() << " : " << pCreamDR->Cost() << endl;
    
    // 深度烘培咖啡豆 + 奶油 + 摩卡
    CondimentDecorator *pCreamMocha = new Mocha(pCreamDR);
    cout << pCreamMocha->Name() << " : " << pCreamMocha->Cost() << endl;
    
    // 深度烘培咖啡豆 + 奶油 + 摩卡 + 糖浆
    CondimentDecorator *pCreamMochaSyrup = new Syrup(pCreamMocha);
    cout << pCreamMochaSyrup->Name() << " : " << pCreamMochaSyrup->Cost() << endl;
    
    SAFE_DELETE(pSyrup);
    SAFE_DELETE(pMocha);
    SAFE_DELETE(pCream);
    SAFE_DELETE(pHouseBlend);
    
    SAFE_DELETE(pCreamMochaSyrup);
    SAFE_DELETE(pCreamMocha);
    SAFE_DELETE(pCreamDR);
    SAFE_DELETE(pDarkRoast);
    
    getchar();
    
    return 0;
}
```

输出如下：

```
HouseBlend : 30 HouseBlend Cream : 33.5 HouseBlend Mocha : 32 HouseBlend Syrup : 33 
DarkRoast : 28.5 DarkRoast Cream : 32 DarkRoast Cream Mocha : 34 DarkRoast Cream Mocha Syrup : 37
```

调味品可以随便组合，甚至同一调味品可以添加多份（例如：来 三份糖浆）或者同时添加奶、摩卡和糖浆。



# 常用模式9：代理模式

## 简述

> 代理模式（Proxy Pattern）为其他对象提供了一种代理，**以控制对这个对象的访问**。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间**起到中介的作用**。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com/MrRen-sdhm/Images/raw/master/img/20200823111835.png" width="450px" /> </div>

- Subject（抽象主题）：声明了 RealSubject 与 Proxy 的共同接口，定义了某个/些功能。
- RealSubject（真实主题）：通常执行具体的业务逻辑，Proxy 控制对它的访问。
- Proxy（代理）：持有一个 RealSubject 引用（指针），可以在需要时将请求转发给 RealSubject，以此起到代理的作用。
- Client（客户端）：通过 Proxy 间接地与 RealSubject 进行交互。 注意： Proxy 和 RealSubject 都实现了 Subject 的接口，这允许 Client 可以像处理 RealSubject 一样处理 Proxy。



## 优缺点

优点：

- 代理模式能将代理对象与真正被调用的对象分离，在一定程度上**降低了系统的耦合度**。
- 在客户端和目标对象之间，代理起到一个中介作用，这样**可以保护目标对象**。在对目标对象调用之前，代理对象也可以进行其他操作。

缺点：

- 这种模式引入了另一个抽象层，这有时可能是一个问题。如果真实主题被某些客户端直接访问，并且其中一些客户端可能访问代理类，这可能会导致不同的行为。
- 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。
- 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。



## 适用场景

根据目的和实现方式的不同，代理模式可分为很多种，常见的有：

- 远程代理（Remote Proxy） 为一个位于不同地址空间的对象提供一个本地代理，对代理的方法调用会导致对远程对象的方法调用。ATM 就是一个例子，ATM 可能会持有（存在于远程服务器中的）银行信息的一个代理对象。
- 虚拟代理（Virtual Proxy） 使用虚拟代理，代理可以作为一个（资源消耗较大的）对象的代表。虚拟代理经常延迟对象的创建，直到需要为止。在创建对象之前（及创建对象过程中），虚拟代理也可以作为对象的代理；之后，代理将请求直接委托给 RealSubject。
- 保护代理（Protection Proxy） 根据访问权限，可以使用保护代理来控制对资源的访问。例如，有一个员工对象，保护代理可以允许普通员工调用对象的某些方法，管理员调用其他方法。
- 缓冲代理（Cache Proxy） 为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
- 智能引用代理（Smart Reference Proxy） 当一个对象被引用时，提供一些额外的操作（例如：将对象被调用的次数记录下来）。



## 案例分析

中国移动 - 代理商

在现实生活中，代理无处不在 - 代购、手机代理商、火车票代售点。。。

记得刚上大学时，去学校报道，基本上都要买手机（好怀念 Nokia）、办卡、充值。学校附近的各种代理点很多：“办卡、办卡，动感地带月租只要 18 啦”、“充值、充值，充 100 送 50”。。。各种吆喝声此起彼伏 O(∩_∩)O哈哈~

这里，代理模式可以理解为：移动公司把充值的职责托付给代理点，代理点代替移动公司充值，客户直接与代理点打交道，而非移动公司。



## 代码实现

### 创建抽象主题

定义一个电信运行商 ITelco，并为其提供一个接口 Recharge()，用于充值：

```cpp
// subject.h
#ifndef SUBJECT_H
#define SUBJECT_H

// 电信运营商
class ITelco
{
public:
    virtual ~ITelco(){}
    virtual void Recharge(int money) = 0;  // 充值
};

#endif // SUBJECT_H
```



### 创建真实主题

我一直用的是移动，所以就选它吧！它继承自抽象主题类，提供了业务方法的具体实现：

```cpp
// real_subject.h
#ifndef REAL_SUBJECT_H
#define REAL_SUBJECT_H

#include "subject.h"
#include <iostream>

// 中国移动
class CMCC : public ITelco
{
public:
    void Recharge(int money) override {
        std::cout << "Recharge " << money;
    }
};

#endif // REAL_SUBJECT_H
```



### 创建代理

由于刚开学，代理点生意十分火爆，小顾客顾不上 - 低于 50 不充：

```cpp
// proxy.h
#ifndef PROXY_H
#define PROXY_H

#include "subject.h"
#include "real_subject.h"
#include <iostream>

// 代理点
class Proxy : public ITelco
{
public:
    Proxy() : m_pCMCC(NULL) {}
    ~Proxy() { delete m_pCMCC; }

    // 低于 50 不充
    void Recharge(int money) override {
        if (money >= 50) {
            if (m_pCMCC == NULL)
                m_pCMCC = new CMCC();
            m_pCMCC->Recharge(money);
        } else {
            std::cout << "Sorry, too little money" << std::endl;
        }
    }

private:
    CMCC *m_pCMCC;
};

#endif // PROXY_H
```

注意： 代理类也是抽象主题类的子类，调用时可以在原有业务方法的基础上附加一些新的方法，来对功能进行扩充或约束。



### 创建客户端

现在，开始排队办业务啦：

```cpp
// main.cpp
#include "proxy.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    Proxy* proxy = new Proxy();
    proxy->Recharge(20);
    proxy->Recharge(100);

    SAFE_DELETE(proxy);
    
    getchar();
    
    return 0;
}
```

输出如下：

```
Sorry, too little money 
Recharge 100
```

一开始我们拿了 20 块钱去充值，代理点不给充。。。一怒之下，狂甩 100！



# 常用模式10：观察者模式

## 简述

> 观察者模式（Observer Pattern），定义了对象间的**一对多的依赖关系**，让多个观察者对象同时监听某一个主题对象（被观察者）。**当主题对象的状态发生更改时，会通知所有观察者，让它们能够自动更新**。

背景很多时候，在应用程序的一部分发生更改时，需要同时更新应用程序的其他部分。有一种方法是：让接收者反复检查发送者来进行更新，但是这种方法存在两个主要问题：

占用大量的 CPU 时间来检查新的状态依赖于检测更新的时间间隔，可能不会立即获得更新对于这个问题，有一个简单的解决方案 - 观察者模式。



## 模式结构

UML 结构图：

<div align="center"> <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200603140033.png" width="750px" /> </div>

- Subject（抽象主题）：跟踪所有观察者，并提供添加和删除观察者的接口。
- Observer（抽象观察者）：为所有的具体观察者定义一个接口，在得到主题的通知时进行自我更新。
- ConcreteSubject（具体主题）：将有关状态存入各 ConcreteObserver 对象。当具体主题的状态发生任何更改时，通知所有观察者。
- ConcreteObserver（具体观察者）：实现 Observer 所要求的更新接口，以便使本身的状态与主题的状态相协调。



## 优缺点

优点：

- 观察者和被观察者是抽象耦合的
- 建立一套触发机制

缺点：

- 如果一个被观察者对象有很多的直接和间接的观察者，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。



## 适用场景

- 有多个子类共有的方法，且逻辑相同。
- 重要的、复杂的方法，可以考虑作为模板方法。



## 案例分析

滴滴一下，让出行更美好

自从有了滴滴、快滴、Uber、神舟等各大打车平台，广大市民的出行便利了不少。但自从合并以后，补助少了，价格也上涨了很多，不 * XX 倍甚至打不到车。。。

滴滴：好，第一个月，价格上调至 12.5。。。 过了不久，心里想着：纳尼，都垄断了，还不多涨涨，果断 15.0。。。

合并就是为了垄断，再无硝烟四起的价格战，整合成统一价格模式，用户也就没有了自由选择权。

在这里，滴滴相当于主题，司机相当于观察者。



## 代码实现

### 创建抽象主题

提供关于注册、注销、通知观察者的接口：

```cpp
// subject.h
#ifndef SUBJECT_H
#define SUBJECT_H

class IObserver;

// 抽象主题
class ISubject
{
public:
    virtual void Attach(IObserver *) = 0;  // 注册观察者
    virtual void Detach(IObserver *) = 0;  // 注销观察者
    virtual void Notify() = 0;  // 通知观察者
};

#endif // SUBJECT_H
```



### 创建具体主题

抽象主题的具体实现，用于管理所有的观察者：

```cpp
// concrete_subject.h
#ifndef CONCRETE_SUBJECT_H
#define CONCRETE_SUBJECT_H

#include "subject.h"
#include "observer.h"
#include <iostream>
#include <list>

using namespace std;

// 具体主题
class ConcreteSubject : public ISubject
{
public:
    ConcreteSubject() { m_fPrice = 10.0; }

    void SetPrice(float price) {
        m_fPrice = price;
    }
    
    void Attach(IObserver *observer) {
        m_observers.push_back(observer);
    }
    
    void Detach(IObserver *observer) {
        m_observers.remove(observer);
    }
    
    void Notify() {
        list<IObserver *>::iterator it = m_observers.begin();
        while (it != m_observers.end()) {
            (*it)->Update(m_fPrice);
            ++it;
        }
    }

private:
    list<IObserver *> m_observers;  // 观察者列表
    float m_fPrice;  // 价格
};

#endif // CONCRETE_SUBJECT_H
```



### 创建抽象观察者

提供一个 Update() 接口，用于更新价格：

```cpp
// observer.h
#ifndef OBSERVER_H
#define OBSERVER_H

// 抽象观察者
class IObserver
{
public:
    virtual void Update(float price) = 0;  // 更新价格
};

#endif // OBSERVER_H
```



### 创建具体观察者

抽象观察者的具体实现，当接收到通知后，调整对应的价格：

```cpp
// concrete_observer.h
#ifndef CONCRETE_OBSERVER_H
#define CONCRETE_OBSERVER_H

#include "observer.h"
#include <iostream>
#include <string>

using namespace std;

// 具体观察者
class ConcreteObserver : public IObserver
{
public:
    ConcreteObserver(string name) { m_strName = name; }

    void Update(float price) {
        cout << m_strName << " - price: " << price << "\n";
    }

private:
     string m_strName;  // 名字
};

#endif // CONCRETE_OBSERVER_H
```



### 创建客户端

创建主题以及对应的观察者，并添加观察者并更新价格：

```cpp
// main.cpp
#include "concrete_subject.h"
#include "concrete_observer.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

int main()
{
    // 创建主题、观察者
    ConcreteSubject *pSubject = new ConcreteSubject();
    IObserver *pObserver1 = new ConcreteObserver("Jack Ma");
    IObserver *pObserver2 = new ConcreteObserver("Pony");

    // 注册观察者
    pSubject->Attach(pObserver1);
    pSubject->Attach(pObserver2);
    
    // 更改价格，并通知观察者
    pSubject->SetPrice(12.5);
    pSubject->Notify();
    
    // 注销观察者
    pSubject->Detach(pObserver2);
    // 再次更改状态，并通知观察者
    pSubject->SetPrice(15.0);
    pSubject->Notify();
    
    SAFE_DELETE(pObserver1);
    SAFE_DELETE(pObserver2);
    SAFE_DELETE(pSubject);
    
    getchar();
    
    return 0;
}
```

输出如下：

```
Jack Ma - price: 12.5 
Pony - price: 12.5 
Jack Ma - price: 15
```

开始，我们创建了一个主题（滴滴）以及两个观察者（Jack Ma & Pony），通过 attach() 将他们加入至司机行列。调用 setPrice(12.5)，通知他们起步价为 12.5 元。后来呢，司机 Pony 由于种种原因（~~O(∩_∩)O~~大家都懂得）离职了 - detach() 注销。。。价格再次上调，涨、涨、涨 setPrice(15.0)。。。